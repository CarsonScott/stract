# Stract

Stract is an object-oriented data system for building representations of python objects and classes at run-time. Stract highlights a particular methodology in which there are two main data structures called models and templates. Models are representations of objects that can be converted into dictionaries, and templates are schemas that are used to create new models. Models are to templates as objects are to classes in typical object-oriented programming, however a template in Stract can be defined at run-time.

Models allow information to be passed around to different subsystems in a program. In game development, for example, a player model would be distinct from the player class, which deals with controls, movement, and display, dealing more with the data regarding player state like position and health. Enemies loaded into the game can use the player model update their behavior trees without having direct access to the player instance directly.

The player model does not change as it’s passed around to different subsystems. It simply conveys information about the player to other parts of the program that would not otherwise have access. Models describe objects with dictionaries and are intended to work seamlessly with normal python objects. A model is generated from an existing object by copying its attributes and allowing the programmer to access them directly using a dictionary.

Templates are structures that generate 'instances' of a model. They hold the appropriate information needed to construct new models with information already stored. The purpose of using models and templates is to escape the constraints that prevent easy access and transmission of information across the different substystems of a given code base. Written in python, the ease and flow of Stract enables the programmer to focus more on creative problem-solving and spend less time dealing with low-level technicalities. A complicated conversion between two unfriendly data types is handled easier because it is mapped down to a simpler problem space. All python objects can generate models that share the same basic format and thus are more comparable.

Templates are saved in configuration files and loaded back in at any time. New templates are formed from existing templates by extending them with additional attributes and information. Since model type is determined by attributes, a template is essentially a representation of a type as it holds information required to create new instances. Since a template can produce an unlimited number of instances, there are likely to be multiple models of the same type being used at any given time.

Comparison between structures in Stract is performed using multiple methods. Similarities are made between the attributes and values within different models via set-theoretic operations to deal with type comparisons ('types' are determined by the names or keys of the attributes contained by a model). Two models can be used to create a dictionary containing the shared attributes between them, with each attribute assigned to a tuple containing the values associated with that attribute from both models.

Despite its generality, classification within Stract becomes intuitive as familiarity grows with whatever structures are being used for a particular application. All tasks inevitably yield certain patterns of data, and are seamlessly translated into the ‘language’ of Stract, because models are specifically designed to work well with the object-oriented features of python.

Regular python objects can be updated using models by creating a simple method that takes attributes from a model and assigns class variables to their values. There is meant to be no change in difficulty when scaling from small amounts of data to large amounts in terms of transmission and accessibility. Complicated sets of data are presented in the exact same way as simple sets and are intended to be as straight-forward as possible. The goal of Stract is to minimize the sorts of problems that we often run into throughout development, and increase productivity and enjoyment of the programmer by making flow, freedom, and flexibility the top priority. 
